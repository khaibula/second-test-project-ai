---
description: 
globs: 
alwaysApply: true
---
# Реализация TypeScript

*   Включите максимально строгий режим в `typescript`.
*   Используйте защиту типов для безопасной обработки потенциальных неопределенных или нулевых значений.
*   Применяйте универсальные типы к функциям, действиям и срезам, где требуется гибкость типов.
*   Используйте служебные типы TypeScript (`Partial`, `Pick`, `Omit`) для более чистого и многократно используемого кода.
*   Предпочитайте `interface`, а не `type` для определения структур объектов, особенно при расширении.

# Архитектура Компонентов (React)

*   Используйте функциональные компоненты с интерфейсами TypeScript.
*   Определяйте компоненты с помощью ключевого слова `function`.
*   Извлекайте повторно используемую логику в пользовательские хуки (префикс `use`).
*   Реализуйте правильную композицию компонентов.
*   Используйте `React.memo()` стратегически для оптимизации производительности.
*   Реализуйте правильную очистку в хуках `useEffect`.

# Стилизация (CSS Modules)

*   Используйте CSS Modules для локальной области видимости стилей и предотвращения конфликтов имен.
*   Называйте файлы стилей `ComponentName.module.css` (или `.module.scss`, `.module.less`, если используется препроцессор).
*   Импортируйте стили: `import styles from './ComponentName.module.css';`.
*   Применяйте классы через объект `styles`: `className={styles.myClass}`.
*   Для глобальных стилей используйте обычные `.css` файлы (без `.module`) и импортируйте их в корневом компоненте приложения или точке входа.

# Управление состоянием (State Management)

*   Старайтесь держать состояние как можно более локальным (компонент, хуки).
*   Для простого или редко обновляемого состояния, которое нужно передавать через несколько уровней компонентов, используйте React **Context API**.
    *   Создавайте отдельные контексты для несвязанных данных, чтобы избежать ненужных повторных рендеров.
*   Для сложного, глобального или часто обновляемого состояния, а также состояния, требующего сложной логики (мидлвары, вычисляемые значения), используйте **Zustand**.
    *   Разбивайте хранилище (store) на логические срезы (slices) для лучшей организации.

# Взаимодействие с API (Data Fetching)

*   Используйте **axios** для выполнения HTTP-запросов.
    *   Создайте настроенный экземпляр `axios` для общих конфигураций (базовый URL, заголовки, перехватчики).
*   Используйте **React Query** для управления состоянием серверных данных, кэширования, синхронизации и фонового обновления.
    *   Оборачивайте запросы `axios` в функции, которые будут использоваться с хуками `React Query` (`useQuery`, `useMutation`, `useInfiniteQuery`).
    *   Определяйте уникальные ключи запросов (`query keys`) для управления кэшем.
    *   Создавайте пользовательские хуки (например, `useFetchUserData`), инкапсулирующие логику `React Query` для конкретных данных, чтобы упростить их использование в компонентах.

# Формы (Forms)

*   Используйте **React Hook Form** для управления состоянием форм, валидации и отправки данных.
    *   Это обеспечивает высокую производительность за счет неконтролируемых компонентов и минимизации перерисовок.
*   Используйте **zod** для определения схем валидации, чтобы четко определить правила и получить строгую типизацию.
*   Используйте хук `useForm` для инициализации формы и получения методов (`register`, `handleSubmit`, `formState`, etc.).
*   Интегрируйте с библиотеками UI-компонентов с помощью `Controller` или `useController`, если это необходимо.
