---
description: 
globs: 
alwaysApply: true
---
# Архитектура Фронтенд Приложений

## Feature-Sliced Design (FSD)

Мы используем методологию **Feature-Sliced Design (FSD)** для организации структуры проекта и управления потоком зависимостей.

*   **Структура Слоев:** Проект делится на основные слои (от нижнего к верхнему):
    1.  `shared`: Переиспользуемый код, не зависящий от бизнес-логики (UI-кит, утилиты, API-клиенты).
    2.  `entities`: Бизнес-сущности (Пользователь, Продукт, Заказ).
    3.  `features`: Взаимодействия пользователя с бизнес-сущностями (Добавить в корзину, Отправить сообщение).
    4.  `widgets`: Композиционные блоки интерфейса, объединяющие entities и features (Хедер, Сайдбар, Список товаров).
    5.  `pages`: Страницы приложения, композирующие виджеты, entities и features.
    6.  `app`: Инициализация приложения, глобальные стили, провайдеры, роутинг.
*   **Правило Импорта:** Код может импортировать модули только из слоев, расположенных **ниже** в иерархии (например, `features` могут импортировать из `entities` и `shared`, но не из `widgets` или `pages`).
*   **Слайсы (Slices):** Внутри слоев (`entities`, `features`, `widgets`, `pages`) код группируется по функциональным областям (слайсам).
*   **Public API:** Каждый слайс должен иметь точку входа (`index.ts` или `index.tsx`), которая экспортирует только то, что предназначено для использования извне. Это обеспечивает слабую связанность между слайсами одного слоя.
*   **Сегменты:** Внутри слайса код может быть разделен на сегменты (`ui`, `model`, `lib`, `api`, `config`) для лучшей организации.

## Принципы Чистого Кода и Архитектуры

*   **Консистентность:** Стремитесь к единообразию во всем проекте – в именовании, структуре файлов и каталогов, стиле кода, архитектурных паттернах. Используйте существующие правила и руководства (`development-guidelines.mdc`, `react-typescript-guidelines.mdc`).
*   **Инкапсуляция:** Скрывайте детали реализации. Компоненты, модули и слои должны предоставлять четкий и минимально необходимый интерфейс (Public API в FSD), скрывая свою внутреннюю структуру и логику. Инкапсулируйте части системы, которые подвержены изменениям.
*   **Принципы SOLID:**
    *   **S**ingle Responsibility Principle (Принцип единственной ответственности): Каждый модуль, класс или функция должны иметь одну и только одну причину для изменения.
    *   **O**pen/Closed Principle (Принцип открытости/закрытости): Программные сущности должны быть открыты для расширения, но закрыты для модификации.
    *   **L**iskov Substitution Principle (Принцип подстановки Барбары Лисков): Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
    *   **I**nterface Segregation Principle (Принцип разделения интерфейса): Клиенты не должны зависеть от методов, которые они не используют. Создавайте мелкие, специфичные интерфейсы.
    *   **D**ependency Inversion Principle (Принцип инверсии зависимостей): Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. (FSD помогает в этом).
*   **Разделение Ответственности (Separation of Concerns - SoC):** Четко разделяйте код по его назначению (UI, бизнес-логика, работа с данными, утилиты). FSD структура способствует этому разделению.
*   **Слабая Связанность (Loose Coupling) и Высокая Сплоченность (High Cohesion):** Модули должны быть как можно менее зависимы друг от друга (слабая связанность) и содержать только тесно связанную функциональность (высокая сплоченность).
